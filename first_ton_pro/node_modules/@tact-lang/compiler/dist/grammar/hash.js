"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AstHasher = void 0;
const crypto_1 = require("crypto");
const errors_1 = require("../errors");
const json_bigint_1 = __importDefault(require("json-bigint"));
/**
 * Provides functionality to hash AST nodes regardless of identifiers.
 */
class AstHasher {
    sort;
    constructor(sort) {
        this.sort = sort;
    }
    static make(params = {}) {
        const { sort = true } = params;
        return new AstHasher(sort);
    }
    hash(node) {
        const data = node.kind === "id" || node.kind === "func_id"
            ? `${node.kind}_${node.text}`
            : this.getHashData(node);
        return (0, crypto_1.createHash)("sha256").update(data).digest("hex");
    }
    /**
     * Generates a string that is used to create a hash.
     */
    getHashData(node) {
        switch (node.kind) {
            case "module":
                return this.hashModule(node);
            case "struct_decl":
                return this.hashStructDecl(node);
            case "message_decl":
                return this.hashMessageDecl(node);
            case "function_def":
                return this.hashFunctionDef(node);
            case "constant_def":
                return this.hashConstantDef(node);
            case "trait":
                return this.hashTrait(node);
            case "contract":
                return this.hashContract(node);
            case "field_decl":
                return this.hashFieldDecl(node);
            case "primitive_type_decl":
                return `${node.kind}|${node.name.kind}`;
            case "contract_init":
                return this.hashContractInit(node);
            case "native_function_decl":
                return this.hashNativeFunctionDecl(node);
            case "receiver":
                return this.hashReceiver(node);
            case "id":
                return "id";
            case "func_id":
                return "func_id";
            case "typed_parameter":
                return this.hashTypedParameter(node);
            case "function_decl":
                return this.hashFunctionDecl(node);
            case "struct_field_initializer":
                return this.hashStructFieldInitializer(node);
            case "import":
                return this.hashImport(node);
            case "constant_decl":
                return this.hashConstantDecl(node);
            // Statements
            case "statement_let":
                return `${node.kind}|${node.type ? this.hash(node.type) : "null"}|${this.hash(node.expression)}`;
            case "statement_return":
                return `${node.kind}|${node.expression ? this.hash(node.expression) : "null"}`;
            case "statement_expression":
                return `${node.kind}|${this.hash(node.expression)}`;
            case "statement_assign":
                return `${node.kind}|${this.hash(node.path)}|${this.hash(node.expression)}`;
            case "statement_augmentedassign":
                return `${node.kind}|${node.op}|${this.hash(node.path)}|${this.hash(node.expression)}`;
            case "statement_condition": {
                const trueStatementsHash = this.hashStatements(node.trueStatements);
                const falseStatementsHash = node.falseStatements
                    ? this.hashStatements(node.falseStatements)
                    : "null";
                const elseifHash = node.elseif
                    ? this.hash(node.elseif)
                    : "null";
                return `${node.kind}|${this.hash(node.condition)}|${trueStatementsHash}|${falseStatementsHash}|${elseifHash}`;
            }
            case "statement_while":
                return `${node.kind}|${this.hash(node.condition)}|${this.hashStatements(node.statements)}`;
            case "statement_until":
                return `${node.kind}|${this.hash(node.condition)}|${this.hashStatements(node.statements)}`;
            case "statement_repeat":
                return `${node.kind}|${this.hash(node.iterations)}|${this.hashStatements(node.statements)}`;
            case "statement_try":
                return `${node.kind}|${this.hashStatements(node.statements)}`;
            case "statement_try_catch":
                return `${node.kind}|${this.hashStatements(node.statements)}|${this.hash(node.catchName)}|${this.hashStatements(node.catchStatements)}`;
            case "statement_foreach":
                return `${node.kind}|${this.hash(node.map)}|${this.hashStatements(node.statements)}`;
            // Expressions
            case "op_binary":
                return `${node.kind}|${node.op}|${this.hash(node.left)}|${this.hash(node.right)}`;
            case "op_unary":
                return `${node.kind}|${node.op}|${this.hash(node.operand)}`;
            case "field_access":
                return `${node.kind}|${this.hash(node.aggregate)}|${node.field.kind}`;
            case "method_call": {
                const argsHash = node.args
                    .map((arg) => this.hash(arg))
                    .join("|");
                return `${node.kind}|${argsHash}`;
            }
            case "static_call": {
                const staticArgsHash = node.args
                    .map((arg) => this.hash(arg))
                    .join("|");
                return `${node.kind}|${staticArgsHash}`;
            }
            case "struct_instance": {
                const structArgsHash = node.args
                    .map((arg) => this.hashStructFieldInitializer(arg))
                    .join("|");
                return `${node.kind}|${structArgsHash}`;
            }
            case "init_of": {
                const initArgsHash = node.args
                    .map((arg) => this.hash(arg))
                    .join("|");
                return `${node.kind}|${initArgsHash}`;
            }
            case "conditional":
                return `${node.kind}|${this.hash(node.condition)}|${this.hash(node.thenBranch)}|${this.hash(node.elseBranch)}`;
            case "number":
                return `${node.kind}|${node.value}`;
            case "boolean":
                return `${node.kind}|${node.value}`;
            case "string":
                return `${node.kind}|${node.value}`;
            case "null":
                return node.kind;
            // Types
            case "type_id":
                return `${node.kind}|${node.text}`;
            case "optional_type":
                return `${node.kind}|${this.hash(node.typeArg)}`;
            case "map_type": {
                const keyStorageHash = node.keyStorageType
                    ? this.hash(node.keyStorageType)
                    : "null";
                const valueStorageHash = node.valueStorageType
                    ? this.hash(node.valueStorageType)
                    : "null";
                return `${node.kind}|${this.hash(node.keyType)}|${keyStorageHash}|${this.hash(node.valueType)}|${valueStorageHash}`;
            }
            case "bounced_message_type":
                return `${node.kind}|${this.hash(node.messageType)}`;
            default:
                (0, errors_1.throwInternalCompilerError)(`Unsupported node: ${json_bigint_1.default.stringify(node)}`);
        }
    }
    hashStructDecl(node) {
        const fieldsHash = this.hashFields(node.fields);
        return `struct|${fieldsHash}`;
    }
    hashMessageDecl(node) {
        const fieldsHash = this.hashFields(node.fields);
        return `message|${fieldsHash}|${node.opcode}`;
    }
    hashFunctionDef(node) {
        const attributesHash = this.hashAttributes(node.attributes);
        const returnHash = node.return ? this.hash(node.return) : "void";
        const paramsHash = this.hashParams(node.params);
        const statementsHash = this.hashStatements(node.statements);
        return `function|${attributesHash}|${returnHash}|${paramsHash}|${statementsHash}`;
    }
    hashConstantDef(node) {
        const attributesHash = this.hashAttributes(node.attributes);
        const typeHash = this.hash(node.type);
        const initializerHash = this.hash(node.initializer);
        return `constant|${attributesHash}|${typeHash}|${initializerHash}`;
    }
    hashTrait(node) {
        const traitsHash = this.hashIds(node.traits);
        const attributesHash = this.hashContractAttributes(node.attributes);
        const declarationsHash = this.hashDeclarations(node.declarations);
        return `trait|${traitsHash}|${attributesHash}|${declarationsHash}`;
    }
    hashContract(node) {
        const traitsHash = this.hashIds(node.traits);
        const attributesHash = this.hashContractAttributes(node.attributes);
        const declarationsHash = this.hashDeclarations(node.declarations);
        return `contract|${traitsHash}|${attributesHash}|${declarationsHash}`;
    }
    hashFields(fields) {
        let hashedFields = fields.map((field) => this.hashFieldDecl(field));
        if (this.sort) {
            hashedFields = hashedFields.sort();
        }
        return hashedFields.join("|");
    }
    hashParams(params) {
        let hashedParams = params.map((param) => this.hashTypedParameter(param));
        if (this.sort) {
            hashedParams = hashedParams.sort();
        }
        return hashedParams.join("|");
    }
    hashTypedParameter(param) {
        const typeHash = this.hash(param.type);
        return `param|${typeHash}`;
    }
    hashAttributes(attributes) {
        return attributes
            .map((attr) => attr.type)
            .sort()
            .join("|");
    }
    hashContractAttributes(attributes) {
        return attributes
            .map((attr) => `${attr.type}|${attr.name.value}`)
            .sort()
            .join("|");
    }
    hashIds(ids) {
        return ids
            .map((id) => id.kind)
            .sort()
            .join("|"); // Ignore actual id.text, just hash based on kind
    }
    hashDeclarations(declarations) {
        let hashedDeclarations = declarations.map((decl) => this.hash(decl));
        if (this.sort) {
            hashedDeclarations = hashedDeclarations.sort();
        }
        return hashedDeclarations.join("|");
    }
    hashStatements(statements) {
        let hashedStatements = statements.map((stmt) => this.hash(stmt));
        if (this.sort) {
            hashedStatements = hashedStatements.sort();
        }
        return hashedStatements.join("|");
    }
    hashStructFieldInitializer(initializer) {
        return `field_initializer|${this.hash(initializer.initializer)}`;
    }
    hashFieldDecl(field) {
        const typeHash = this.hash(field.type);
        return `field|${typeHash}`;
    }
    hashContractInit(node) {
        const paramsHash = this.hashParams(node.params);
        const statementsHash = this.hashStatements(node.statements);
        return `${node.kind}|${paramsHash}|${statementsHash}`;
    }
    hashNativeFunctionDecl(node) {
        const attributesHash = this.hashAttributes(node.attributes);
        const paramsHash = this.hashParams(node.params);
        const returnHash = node.return ? this.hash(node.return) : "void";
        return `${node.kind}|${attributesHash}|${paramsHash}|${returnHash}`;
    }
    hashReceiver(node) {
        const selectorHash = node.selector.kind;
        const statementsHash = this.hashStatements(node.statements);
        return `${node.kind}|${selectorHash}|${statementsHash}`;
    }
    hashFunctionDecl(node) {
        const attributesHash = this.hashAttributes(node.attributes);
        const returnHash = node.return ? this.hash(node.return) : "void";
        const paramsHash = this.hashParams(node.params);
        return `${node.kind}|${attributesHash}|${returnHash}|${paramsHash}`;
    }
    hashImport(node) {
        return `${node.kind}|${this.hash(node.path)}`;
    }
    hashConstantDecl(node) {
        const attributesHash = this.hashAttributes(node.attributes);
        const typeHash = this.hash(node.type);
        return `${node.kind}|${attributesHash}|${typeHash}`;
    }
    hashModule(node) {
        const importsHash = this.hashImports(node.imports);
        const itemsHash = this.hashModuleItems(node.items);
        return `${node.kind}|${importsHash}|${itemsHash}`;
    }
    hashImports(imports) {
        let hashedImports = imports.map((imp) => this.hash(imp));
        if (this.sort) {
            hashedImports = hashedImports.sort();
        }
        return hashedImports.join("|");
    }
    hashModuleItems(items) {
        let hashedItems = items.map((item) => this.hash(item));
        if (this.sort) {
            hashedItems = hashedItems.sort();
        }
        return hashedItems.join("|");
    }
}
exports.AstHasher = AstHasher;
